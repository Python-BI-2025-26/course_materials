# HW 4. Modules

Состоит из нескольких пунктов. В итоге у вас получится ваш первый настоящий пакет с биоинформатическими утилитами!

## Описание ДЗ

1. Создайте ***у себя*** **публичный  репозиторий❗️** для ваших бионф-утилит, назовите как-нибудь по биоинформатически-утилитски.  Далее делайте **всю работу в ❗️ОТДЕЛЬНОЙ ВЕТКЕ❗️**. 

2. В новой ветке вам нужно будет реализовать несколько файлов: *главный скрипт* `*.py`, `README.md` и папка с модулями. Структура вашего пакета будет выглядеть вот так:
 
```python
-/
|- README.md
|- главный скрипт.py # (импорты и 2 функции)
|- папка/
    |- доп_модуль.py
    |- доп_модуль_2.py
    |- ...
``` 

### Содержимое файлов

- *Главный скрипт* `*.py` </br>
    Это *точка входа* в вашу программу. Принято чтобы он назывался как и ваши биоинф-утилиты (как и репозиторий, только без спец.символов). Либо можно `main.py`. 

    В главном скрипте находятся **только**:
    - Импорты
    - Функция `run_dna_rna_tools` из прошлой домашки
    - Функция `filter_fastq` (про нее ниже)
    
    Также в главном файле возможно определение констант, если вы знаете что это, но больше ничего там находиться не должно!

- Папка с доп. модулями </br>
    Тут располагаются модули, внутри которых будут находиться любые другие переменные и функции (`reverse`, `transcribe`, ...). Количество, содержимое и структура модулей зависит от того как лично вы продумаете дизайн вашего пакета.

- `README.md` </br>
    Здесь вы описываете все что касается установки и использования вашего пакета. Введение, примеры, контакты - все что посчитаете нужным. Он не должен быть большим, это не документация (для этого любому репозиторию можно сделать Wiki). Ридми это лакончиная и структурированная выжимка важной информации. Примеры ридми можно посмотреть здесь: [раз](https://github.com/ctlab/metafast), [два](https://github.com/pandas-dev/pandas) и [три](https://youtu.be/dQw4w9WgXcQ?si=rBRoRjL9G4L3qTZB).


### Функция `filter_fastq`

Напишите утилиту для работы с fastq-последовательностями (по аналогии с ДЗ по ДНК/РНК). Главная функция `filter_fastq` принимает на вход 4 аргумента: `seqs`, `gc_bounds`, `length_bounds`, `quality_threshold`:
-  `seqs` - словарь, состоящий из fastq-сиквенсов. Структура следующая. Ключ - строка, имя последовательности. Значение - кортеж из двух строк: последовательность и качество. По сути это содержание fastq-файла, но мы с вами пока не проходили чтение файлов. Так что пока используем python-словарь. Потом достаточно будет добавить чтение файлов и сохранение их в словарь такого вида, чтобы всё работало от начала и до конца. В скрипте `example_data.py` для вас сделан пример для отладки.
- `gc_bounds` - интервал GC состава (в процентах) для фильтрации (по-умолчанию равен `(0, 100)`, т. е. все риды сохраняются). Если в аргумент передать одно число, то считается, что это верхняя граница. Примеры: `gc_bounds = (20, 80)` - сохраняем только риды с GC составом от 20 до 80%, `gc_bounds = 44.4` - сохраняем риды с GC составом меньше, чем 44.4%.
- `length_bounds` - интервал длины для фильтрации, всё аналогично `gc_bounds`, но по-умолчанию равен `(0, 2**32)`.
- `quality_threshold` - пороговое значение среднего качества рида для фильтрации, по-умолчанию равно `0` (шкала phred33). Риды со средним качеством по всем нуклеотидам ниже порогового отбрасываются. </br>

Это не должна быть функция-монстр, пусть она делегирует отдельные задачи другим функциям.

**По итогам работы** `filter_fastq` должна возвращать аналогичный словарь, состоящий только из тех сиквенсов, которые удовлетворили всем условиям. Все описанные интервалы включают и верхнюю, и нижнюю границы. Задание должно быть выполнено без использования сторонных (внешних) модулей (т.е. стандартную библиотеку использовать можно). </br>

Про fastq-файлы можно посмотреть, например, [здесь](https://stepik.org/lesson/32398/step/1?unit=12379), про определение качества на основе ASCII-кода можно почитать [здесь](https://support.illumina.com/help/BaseSpace_Sequence_Hub_OLH_009008_2/Source/Informatics/BS/QualityScoreEncoding_swBS.htm), также вам может пригодиться таблица [кодировки ASCII](https://www.asciitable.com/) и функция ord (документация [en](https://docs.python.org/3/library/functions.html#ord), [ru](https://docs-python.ru/tutorial/vstroennye-funktsii-interpretatora-python/funktsija-ord/)).

### Документирование модуля

Важной частью любого пакета является документация. Мы не будем писать отдельную подробную документацию в [таком](https://www.htslib.org/doc/samtools.html) духе. Но мы сделаем наш код хорошо задокументированным. Это включает в себя следующие вещи:

1. Говорящие **имена** переменных и функций, которые удовлетворяют конвенциям по наименованию.

2. **Докстринги** функций. 

Это специальные поля документации которые выглядят вот так:

```python
def divide(x, y):
"""
Computes result of x / y

Arguments:
x: int / float
y: int / float

Returns float. 
Raises exception if y is 0
"""

return x / y
```

Докстринга это человекочитаемый текст написанный сразу под заголовком функции внутри тройных двойных кавычек. Должна быть лакончиной, плюс содержать описание аргументов и результата работы. Поподробнее почитать про них можно в [PEP-257](https://peps.python.org/pep-0257/) (или в [русской версии](https://habr.com/ru/articles/499358/)).

Докстринги прекрасны тем что они потом отображаются в `help(divide)` или в высвечивающейся подсказе при нажатии `Tab`. 

3. **Аннотации типов**

Аннотации типов в Python являются подсказкой какой именно тип данных хранится в *переменной*. 

Заметье, в Python типизация динамическая, переменные могут спокойно менять тип хранимых в них данных! Аннотации типов как и докстринги являются чисто подсказками для человека читающего/пишущего/использующего код. Интерпретатору на них все равно. Есть программки типо [mypy](https://mypy.readthedocs.io/en/stable/#) которые позволяют автоматически проверяеть совпадают ли аннотации с тем что реально попадает в переменные, но это уже за рамками нашего курса. 

Пишутся они следующим образом: через `:` для переменных и аргументов функций и через `->` для результатов функции. 

```python
sequence : str = 'ATG'

def reverse(seq: str) -> str:
    return seq[::-1]
```

Заметьте, когда вы определяете коллекции:
```python
sequences: list = ...
```
вообще говоря не понятно, а что ожидается будет лежать в списке? Начиная с версии 3.9 можно аннотировать содержимое коллекций:
```python
sequences: list[str] = ['ATG', 'TTC']
```

На самом деле в аннотацию можно уходить бесконечно. Можно почитать [PEP-484](https://peps.python.org/pep-0484/) и про встроенный модуль [typing](https://docs.python.org/3/library/typing.html), про всякие штуки типо `Union`, `Optional`, `Any`, `type alias` и т.п. ... Могу только похвалить тех кто захочет это сделать и применить в своем пакете, но для выполнения ДЗ ожидается лишь базовый уровень который показан выше. 

Как одновременно указать аргументам функции и аннотации типов и значения по-умолчанию остается на самостоятельное изучение)




## Разбалловка

- Дизайн и структура репозитория: **10 баллов**
- FASTQ-Фильтратор: **40 баллов**
- README: **20 баллов**
- Документирование модуля и качество кода: **25 баллов**
- Наличие улучшений по сравнению с прошлым ДЗ **5 баллов**

#### Предполагаемый учебный результат

Да, последний пункт тоже влияет на оценку. Это задание позволит вам не только закрепить всё то, что мы проходили последние 3 недели, но и даст важный навык - умение читать свой код и исправлять его. Очень часто хочется писать код по принципу "сделал и забыл". Здесь же мы попытаемся заняться итеративной работой над собой и своим продуктом. Иногда это называется умным словом [*agile*](https://www.4gclinical.com/hs-fs/hubfs/waterfall_v_agile.jpg?width=1600&name=waterfall_v_agile.jpg).


## Форма сдачи

- Завершите работу над репозиторием в отдельной ветке локально
- Сделайте `push` этой ветки в репозиторий на `GitHub`
- На `GitHub` откройте pull-request из этой ветки в ветку `main`

- Прикрепите ссылку на свой pull-request в [гугл-форму](https://docs.google.com/forms/d/e/1FAIpQLSfWX01ZPZirb9TWbHuUJ3_kj-98G5wCWjC1OkSEFXSOIzPnhQ/viewform?usp=dialog)

Ветка main/master должна остаться пустой. Пулл-реквест не закрывайте!


Удачи! ✨✨
